
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <meta charset="utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
      <meta class="swiftype" name="neo4j-site" data-type="enum" content="Reference Docs"></meta>
      <meta class="swiftype" name="main-search-priority" data-type="integer" content="3"></meta>
      <title>12.4.&nbsp;Expand to nodes in a subgraph - Chapter&nbsp;12.&nbsp;Advanced Graph Querying</title>
      <link rel="stylesheet" type="text/css" href="../../docbook.css"></link>
      <link rel="stylesheet" type="text/css" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css"></link>
      <link rel="stylesheet" type="text/css" href="//cdn.datatables.net/1.10.13/css/jquery.dataTables.min.css"></link>
      <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css"></link>
      <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Open+Sans:400,300,400italic,600,300italic"></link>
      <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/codemirror.min.css"></link>
      <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/theme/neo.min.css"></link>
      <link rel="stylesheet" type="text/css" href="../../css/chunked-base.css"></link>
      <link rel="stylesheet" type="text/css" href="../../css/extra.css"></link><script src="//code.jquery.com/jquery-1.12.4.js" type="text/javascript"></script><script src="//cdn.datatables.net/1.10.13/js/jquery.dataTables.min.js" type="text/javascript"></script><script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" type="text/javascript"></script><script src="//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/codemirror.min.js" type="text/javascript"></script><script src="//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/addon/runmode/runmode.min.js" type="text/javascript"></script><script src="//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/mode/cypher/cypher.min.js" type="text/javascript"></script><script src="../../javascript/datatable.js" type="text/javascript"></script><script src="../../javascript/colorize.js" type="text/javascript"></script><script src="../../javascript/tabs-for-chunked.js" type="text/javascript"></script><script src="../../javascript/mp-nav.js" type="text/javascript"></script><script src="../../javascript/versionswitcher.js" type="text/javascript"></script><script src="../../javascript/version.js" type="text/javascript"></script><script src="../../javascript/feedback.js" type="text/javascript"></script><script src="//s3-eu-west-1.amazonaws.com/alpha.neohq.net/docs/new-manual/assets/search.js" type="text/javascript"></script><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"></meta>
      <meta name="description" content="This section describes a procedure that expands a subgraph from a set of start nodes, and returns all nodes within the subgraph."></meta>
      <link rel="prev" href="../expand-subgraph/" title="12.5.&nbsp;Expand to subgraph"></link>
      <link rel="next" href="../expand-paths/" title="12.2.&nbsp;Expand paths"></link>
      <link rel="shortcut icon" href="https://neo4j.com/wp-content/themes/neo4jweb/favicon.ico"></link><script>var frontpage_relpath = "../../";
        $(document).ready(function() {
          CodeMirror.colorize();
          tabTheSource($('body'));
          var $header = $('header').first();
          $header.prepend(
            $('<a href="https://neo4j.com/docs/labs/" id="logo"><img src="https://s3.amazonaws.com/dev.assets.neo4j.com/wp-content/uploads/20190802073913/labs-logo6.png" alt="Neo4j Labs Logo"/></a>')
          );
          var sidebar = $('<div id="sidebar-wrapper"/>');
          $.get('toc.html', function (d){
            $(d).appendTo(sidebar);
            highlightToc();
            highlightLibraryHeader();
          });
          sidebar.insertAfter($('header').first());
          
        });

        </script></head>
   <body>
      <header>
         <div class="searchbox">
            <form id="search-form" class="search" name="search-form" role="search"><input id="search-form-input" name="q" title="search" type="search" lang="en" placeholder="Search Neo4j docs..." aria-label="Search Neo4j documentation" max-length="128" required="required"></input><input id="search-form-button" type="submit" value="Search"></input></form>
         </div>
         <ul class="documentation-library">
            <li><a href="https://neo4j.com/docs/labs/apoc/4.0/">APOC</a></li>
            <li><a href="https://neo4j.com/docs/labs/neo4j-streams/current/">Neo4j Streams</a></li>
            <li><a href="https://neo4j.com/docs/labs/nsmntx/current/">Neo Semantics</a></li>
            <li><a href="https://neo4j.com/docs/graph-algorithms/current/">Graph Algorithms</a></li>
            <li><a href="https://neo4j.com/docs/developer-manual/current/">Developer Manual</a></li>
         </ul>
         <nav id="header-nav"><span class="nav-previous"><a accesskey="p" href="../expand-subgraph/"><span class="fa fa-long-arrow-left" aria-hidden="true"></span>Expand to subgraph</a></span><span class="nav-current">
               <p class="nav-title hidden">12.4.&nbsp;Expand to nodes in a subgraph</p></span><span class="nav-next"><a accesskey="n" href="../expand-paths/">Expand paths<span class="fa fa-long-arrow-right" aria-hidden="true"></span></a></span></nav>
      </header>
      <div id="search-results" class="hidden"></div>
      <section class="section" id="expand-subgraph-nodes">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title" style="clear: both"><a class="anchor" href="#expand-subgraph-nodes"></a>12.4.&nbsp;Expand to nodes in a subgraph
                  </h2>
               </div>
            </div>
         </div>
         <div class="abstract">
            <p>This section describes a procedure that expands a subgraph from a set of start nodes, and returns all nodes within the subgraph.</p>
         </div>
         <p>This procedure expands to subgraph nodes reachable from the start node following relationships to max-level adhering to the
            label filters.
            It allows fine grained control over the traversals that expand the subgraph.
         </p>
         <p>This section includes:</p>
         <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
               <li class="listitem"><a class="xref" href="#expand-subgraph-nodes-overview" title="12.4.1.&nbsp;Procedure Overview">Section&nbsp;12.4.1, &#8220;Procedure Overview&#8221;</a></li>
               <li class="listitem"><a class="xref" href="#expand-subgraph-nodes-config" title="12.4.2.&nbsp;Configuration parameters">Section&nbsp;12.4.2, &#8220;Configuration parameters&#8221;</a></li>
               <li class="listitem">
                  <p class="simpara"><a class="xref" href="#expand-subgraph-nodes-examples" title="12.4.3.&nbsp;Examples">Section&nbsp;12.4.3, &#8220;Examples&#8221;</a></p>
                  <div class="itemizedlist">
                     <ul class="itemizedlist" style="list-style-type: circle; ">
                        <li class="listitem"><a class="xref" href="#expand-subgraph-nodes-examples-label-relationship-filters" title="12.4.3.1.&nbsp;Relationship Type and Node Label filters">Section&nbsp;12.4.3.1, &#8220;Relationship Type and Node Label filters&#8221;</a></li>
                        <li class="listitem"><a class="xref" href="#expand-subgraph-nodes-examples-end-nodes-terminator-nodes" title="12.4.3.2.&nbsp;Terminator Nodes and End Nodes">Section&nbsp;12.4.3.2, &#8220;Terminator Nodes and End Nodes&#8221;</a></li>
                        <li class="listitem"><a class="xref" href="#expand-subgraph-nodes-examples-whitelist-blacklist" title="12.4.3.3.&nbsp;Whitelist Nodes and Blacklist Nodes">Section&nbsp;12.4.3.3, &#8220;Whitelist Nodes and Blacklist Nodes&#8221;</a></li>
                        <li class="listitem"><a class="xref" href="#expand-subgraph-nodes-examples-sequence-rel-types" title="12.4.3.4.&nbsp;Sequences of relationship types">Section&nbsp;12.4.3.4, &#8220;Sequences of relationship types&#8221;</a></li>
                     </ul>
                  </div>
               </li>
            </ul>
         </div>
         <section class="section" id="expand-subgraph-nodes-overview">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a class="anchor" href="#expand-subgraph-nodes-overview"></a>12.4.1.&nbsp;Procedure Overview
                     </h3>
                  </div>
               </div>
            </div>
            <p>The procedure is described below:</p>
            <div class="informaltable">
               <div class="table" id="d0e31106">
                  <table class="informaltable" border="1">
                     <colgroup>
                        <col class="col_1"></col>
                        <col class="col_2"></col>
                        <col class="col_3"></col>
                        <col class="col_4"></col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th style="text-align: left; vertical-align: top; ">type</th>
                           <th style="text-align: left; vertical-align: top; ">qualified name</th>
                           <th style="text-align: left; vertical-align: top; ">signature</th>
                           <th style="text-align: left; vertical-align: top; ">description</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>procedure</p>
                           </td>
                           <td style="text-align: left; vertical-align: top; ">
                              <p><code class="literal">apoc.path.subgraphNodes</code></p>
                           </td>
                           <td style="text-align: left; vertical-align: top; ">
                              <p><code class="literal">apoc.path.subgraphNodes(start :: ANY?, config :: MAP?) :: (node :: NODE?)</code></p>
                           </td>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>apoc.path.subgraphNodes(startNode &lt;id&gt;|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false,
                                 limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield node - expand the subgraph
                                 nodes reachable from start node following relationships to max-level adhering to the label filters
                              </p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
            </div>
         </section>
         <section class="section" id="expand-subgraph-nodes-config">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a class="anchor" href="#expand-subgraph-nodes-config"></a>12.4.2.&nbsp;Configuration parameters
                     </h3>
                  </div>
               </div>
            </div>
            <p>The procedures support the following config parameters:</p>
            <div class="table" id="d0e31143">
               <table class="table" summary="Config parameters" border="1">
                  <caption class="table-title">Table&nbsp;12.28.&nbsp;Config parameters</caption>
                  <colgroup>
                     <col class="col_1"></col>
                     <col class="col_2"></col>
                     <col class="col_3"></col>
                     <col class="col_4"></col>
                  </colgroup>
                  <thead>
                     <tr>
                        <th style="text-align: left; vertical-align: top; ">name</th>
                        <th style="text-align: left; vertical-align: top; ">type</th>
                        <th style="text-align: left; vertical-align: top; ">default</th>
                        <th style="text-align: left; vertical-align: top; ">description</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>minLevel</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>Long</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>-1</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>the minimum number of hops in the traversal. Must be 0 or 1 if specified</p>
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>maxLevel</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>Long</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>-1</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>the maximum number of hops in the traversal</p>
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>relationshipFilter</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>String</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>null</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>the relationship types and directions to traverse.</p>
                           <p>See <a class="xref" href="#expand-subgraph-nodes-relationship-filters" title="12.4.2.1.&nbsp;Relationship Filters">Section&nbsp;12.4.2.1, &#8220;Relationship Filters&#8221;</a>.
                           </p>
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>labelFilter</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>String</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>null</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>the node labels to traverse.</p>
                           <p>See <a class="xref" href="#expand-subgraph-nodes-label-filters" title="12.4.2.2.&nbsp;Label Filters">Section&nbsp;12.4.2.2, &#8220;Label Filters&#8221;</a>.
                           </p>
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>beginSequenceAtStart</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>Boolean</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>true</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>starts matching sequences of node labels and/or relationship types (defined in <code class="literal">relationshipFilter</code>, <code class="literal">labelFilter</code>, or <code class="literal">sequences</code>) one node away from the start node.
                           </p>
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>bfs</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>Boolean</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>true</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>use Breadth First Search when traversing. Uses Depth First Search if set to <code class="literal">false</code></p>
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>filterStartNode</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>Boolean</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>false</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>whether the <code class="literal">labelFilter</code> and <code class="literal">sequence</code> apply to the start node of the expansion.
                           </p>
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>limit</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>Long</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>-1</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>limit the number of paths returned. When using <code class="literal">bfs:true</code>, this has the effect of returning paths to the <code class="literal">n</code> nearest nodes with labels in the termination or end node filter, where <code class="literal">n</code> is the limit given.
                              If set to <code class="literal">true</code>, a <code class="literal">null</code> value is yielded whenever the expansion would normally eliminate rows due to no results.
                           </p>
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>endNodes</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>List&lt;Node&gt;</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>null</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>only these nodes can end returned paths, and expansion will continue past these nodes, if possible.</p>
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>terminatorNodes</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>List&lt;Node&gt;</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>null</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>Only these nodes can end returned paths, and expansion won&#8217;t continue past these nodes.</p>
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>whiteListNodes</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>List&lt;Node&gt;</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>null</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>Only these nodes are allowed in the expansion (though endNodes and terminatorNodes will also be allowed, if present).</p>
                        </td>
                     </tr>
                     <tr>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>blackListNodes</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>List&lt;Node&gt;</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>null</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>None of the paths returned will include these nodes.</p>
                        </td>
                     </tr>
                  </tbody>
               </table>
            </div>
            <p>It also has the following fixed parameter:</p>
            <div class="table" id="d0e31360">
               <table class="table" summary="Config parameters" border="1">
                  <caption class="table-title">Table&nbsp;12.29.&nbsp;Config parameters</caption>
                  <colgroup>
                     <col class="col_1"></col>
                     <col class="col_2"></col>
                     <col class="col_3"></col>
                     <col class="col_4"></col>
                  </colgroup>
                  <thead>
                     <tr>
                        <th style="text-align: left; vertical-align: top; ">name</th>
                        <th style="text-align: left; vertical-align: top; ">type</th>
                        <th style="text-align: left; vertical-align: top; ">default</th>
                        <th style="text-align: left; vertical-align: top; ">description</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>uniqueness</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>String</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>NODE_GLOBAL</p>
                        </td>
                        <td style="text-align: left; vertical-align: top; ">
                           <p>the strategy to use when expanding relationships in a traversal.
                              <code class="literal">NODE_GLOBAL</code> means that a node cannot be traversed more than once.
                              This is what the legacy traversal framework does.
                           </p>
                        </td>
                     </tr>
                  </tbody>
               </table>
            </div>
            <section class="section" id="expand-subgraph-nodes-relationship-filters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a class="anchor" href="#expand-subgraph-nodes-relationship-filters"></a>12.4.2.1.&nbsp;Relationship Filters
                        </h4>
                     </div>
                  </div>
               </div>
               <p>The syntax for relationship filters is described below:</p>
               <p>Syntax: <code class="literal">[&lt;]RELATIONSHIP_TYPE1[&gt;]|[&lt;]RELATIONSHIP_TYPE2[&gt;]|&#8230;&#8203;</code></p>
               <div class="informaltable">
                  <div class="table" id="d0e31404">
                     <table class="informaltable" border="1">
                        <colgroup>
                           <col class="col_1"></col>
                           <col class="col_2"></col>
                           <col class="col_3"></col>
                        </colgroup>
                        <thead>
                           <tr>
                              <th style="text-align: left; vertical-align: top; ">input</th>
                              <th style="text-align: left; vertical-align: top; ">type</th>
                              <th style="text-align: left; vertical-align: top; ">direction</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">LIKES&gt;</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">LIKES</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p>OUTGOING</p>
                              </td>
                           </tr>
                           <tr>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">&lt;FOLLOWS</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">FOLLOWS</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p>INCOMING</p>
                              </td>
                           </tr>
                           <tr>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">KNOWS</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">KNOWS</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p>BOTH</p>
                              </td>
                           </tr>
                           <tr>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">&gt;</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">any type</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p>OUTGOING</p>
                              </td>
                           </tr>
                           <tr>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">&lt;</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">any type</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p>INCOMING</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
               </div>
            </section>
            <section class="section" id="expand-subgraph-nodes-label-filters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a class="anchor" href="#expand-subgraph-nodes-label-filters"></a>12.4.2.2.&nbsp;Label Filters
                        </h4>
                     </div>
                  </div>
               </div>
               <p>The syntax for label filters is described below:</p>
               <p>Syntax: <code class="literal">[+-/&gt;]LABEL1|LABEL2|*|&#8230;&#8203;</code></p>
               <div class="informaltable">
                  <div class="table" id="d0e31487">
                     <table class="informaltable" border="1">
                        <colgroup>
                           <col class="col_1"></col>
                           <col class="col_2"></col>
                        </colgroup>
                        <thead>
                           <tr>
                              <th style="text-align: left; vertical-align: top; ">input</th>
                              <th style="text-align: left; vertical-align: top; ">result</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">-Foe</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p>blacklist filter - No node in the path will have a label in the blacklist.</p>
                              </td>
                           </tr>
                           <tr>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">+Friend</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p>whitelist filter - All nodes in the path must have a label in the whitelist (exempting termination and end nodes, if using
                                    those filters).
                                    If no whitelist operator is present, all labels are considered whitelisted.
                                 </p>
                              </td>
                           </tr>
                           <tr>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">/Friend</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p>termination filter - Only return paths up to a node of the given labels, and stop further expansion beyond it.
                                    Termination nodes do not have to respect the whitelist. Termination filtering takes precedence over end node filtering.
                                 </p>
                              </td>
                           </tr>
                           <tr>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p><code class="literal">&gt;Friend</code></p>
                              </td>
                              <td style="text-align: left; vertical-align: top; ">
                                 <p>end node filter - Only return paths up to a node of the given labels, but continue expansion to match on end nodes beyond
                                    it.
                                    End nodes do not have to respect the whitelist to be returned, but expansion beyond them is only allowed if the node has a
                                    label in the whitelist.
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
               </div>
               <p><span class="strong"><strong>Label filter operator precedence and behavior</strong></span></p>
               <p>Multiple label filter operators are allowed at the same time.
                  Take the following example:
               </p>
               <p><code class="literal">labelFilter:'+Person|Movie|-SciFi|&gt;Western|/Romance'</code></p>
               <p>If we work through this label filter, we can see that:</p>
               <div class="itemizedlist">
                  <ul class="itemizedlist" style="list-style-type: disc; ">
                     <li class="listitem"><code class="literal">:Person</code> and <code class="literal">:Movie</code> labels are whitelisted
                     </li>
                     <li class="listitem"><code class="literal">:SciFi</code> is blacklisted
                     </li>
                     <li class="listitem"><code class="literal">:Western</code> is an end node label
                     </li>
                     <li class="listitem"><code class="literal">:Romance</code> is as a termination label.
                     </li>
                  </ul>
               </div>
               <p>The precedence of operator evaluation isn&#8217;t dependent upon their location in the labelFilter but is fixed:</p>
               <p>Blacklist filter <code class="literal">-</code>, termination filter <code class="literal">/</code>, end node filter <code class="literal">&gt;</code>, whitelist filter <code class="literal">+</code>.
               </p>
               <p>This means:</p>
               <div class="itemizedlist">
                  <ul class="itemizedlist" style="list-style-type: disc; ">
                     <li class="listitem">No blacklisted label <code class="literal">-</code> will ever be present in the nodes of paths returned, even if the same label (or another label of a node with a blacklisted
                        label) is included in another filter list.
                     </li>
                     <li class="listitem">If the termination filter <code class="literal">/</code> or end node filter <code class="literal">&gt;</code> is used, then only paths up to nodes with those labels will be returned as results. These end nodes are exempt from the whitelist
                        filter.
                     </li>
                     <li class="listitem">If a node is a termination node <code class="literal">/</code>, no further expansion beyond the node will occur.
                     </li>
                     <li class="listitem">The whitelist only applies to nodes up to but not including end nodes from the termination or end node filters. If no end
                        node or termination node operators are present, then the whitelist applies to all nodes of the path.
                     </li>
                     <li class="listitem">If no whitelist operators are present in the labelFilter, this is treated as if all labels are whitelisted.</li>
                  </ul>
               </div>
            </section>
         </section>
         <section class="section" id="expand-subgraph-nodes-examples">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a class="anchor" href="#expand-subgraph-nodes-examples"></a>12.4.3.&nbsp;Examples
                     </h3>
                  </div>
               </div>
            </div>
            <p>The examples in this section are based on the following sample graph:</p><pre class="programlisting highlight"><code data-lang="cypher">MERGE (mark:Person:DevRel {name: "Mark"})
MERGE (lju:Person:DevRel {name: "Lju"})
MERGE (praveena:Person:Engineering {name: "Praveena"})
MERGE (zhen:Person:Engineering {name: "Zhen"})
MERGE (martin:Person:Engineering {name: "Martin"})
MERGE (joe:Person:Field {name: "Joe"})
MERGE (stefan:Person:Field {name: "Stefan"})
MERGE (alicia:Person:Product {name: "Alicia"})
MERGE (jake:Person:Product {name: "Jake"})
MERGE (john:Person:Product {name: "John"})
MERGE (jonny:Person:Sales {name: "Jonny"})
MERGE (anthony:Person:Sales {name: "Anthony"})
MERGE (rik:Person:Sales {name: "Rik"})

MERGE (zhen)-[:KNOWS]-(stefan)
MERGE (zhen)-[:KNOWS]-(lju)
MERGE (zhen)-[:KNOWS]-(praveena)
MERGE (zhen)-[:KNOWS]-(martin)
MERGE (mark)-[:KNOWS]-(jake)
MERGE (alicia)-[:KNOWS]-(jake)
MERGE (jonny)-[:KNOWS]-(anthony)
MERGE (john)-[:KNOWS]-(rik)

MERGE (alicia)-[:FOLLOWS]-&gt;(joe)
MERGE (joe)-[:FOLLOWS]-&gt;(mark)
MERGE (joe)-[:FOLLOWS]-&gt;(praveena)
MERGE (joe)-[:FOLLOWS]-&gt;(zhen)
MERGE (mark)-[:FOLLOWS]-&gt;(stefan)
MERGE (stefan)-[:FOLLOWS]-&gt;(joe)
MERGE (praveena)-[:FOLLOWS]-&gt;(joe)
MERGE (lju)-[:FOLLOWS]-&gt;(jake)
MERGE (alicia)-[:FOLLOWS]-&gt;(jonny)
MERGE (zhen)-[:FOLLOWS]-&gt;(john)
MERGE (anthony)-[:FOLLOWS]-&gt;(joe)</code></pre><p>The Neo4j Browser visualization below shows the sample graph:</p>
            <div class="figure" id="d0e31619">
               <div class="figure-title">Figure&nbsp;12.7.&nbsp;Sample Graph</div>
               <div class="figure-contents">
                  <div class="mediaobject"><img src="../../images/apoc.path.expandConfig.svg" alt="apoc.path.expandConfig"></img></div>
               </div>
            </div>
            <p>The <code class="literal">KNOWS</code> relationship type is considered to be bidirectional, where if Zhen knows Stefan, we can imply that Stefan knows Zhen.
               When using the <code class="literal">KNOWS</code> relationship we will ignore the direction.
            </p>
            <p>The <code class="literal">FOLLOWS</code> relationship has a direction, so we will specify a direction when we use it.
            </p>
            <section class="section" id="expand-subgraph-nodes-examples-label-relationship-filters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a class="anchor" href="#expand-subgraph-nodes-examples-label-relationship-filters"></a>12.4.3.1.&nbsp;Relationship Type and Node Label filters
                        </h4>
                     </div>
                  </div>
               </div>
               <p>Let&#8217;s start by expanding paths from the Praveena node.
                  We only want to consider the <code class="literal">KNOWS</code> relationship type, so we&#8217;ll specify that as the <code class="literal">relationshipFilter</code> parameter.
               </p>
               <p><span class="formalpara-title">The following returns the people reachable by the <code class="literal">KNOWS</code> relationship at 1 to 2 hops from Praveena.&nbsp;</span>
                  
               </p><pre class="programlisting highlight"><code data-lang="cypher">MATCH (p:Person {name: "Praveena"})
CALL apoc.path.subgraphNodes(p, {
	relationshipFilter: "KNOWS",
    minLevel: 1,
    maxLevel: 2
})
YIELD node
RETURN node;</code></pre><p>
                  
               </p>
               <div class="table" id="d0e31663">
                  <table class="table" summary="Results" border="1">
                     <caption class="table-title">Table&nbsp;12.30.&nbsp;Results</caption>
                     <colgroup>
                        <col class="col_1"></col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th style="text-align: left; vertical-align: top; ">node</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Zhen"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Martin"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:DevRel {name: "Lju"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Field {name: "Stefan"})</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <p>4 people are reachable from Praveena.</p>
               <p>We can also provide a node label filter to restrict the nodes that are returned.
                  If we want to only return paths where every node has the <code class="literal">Engineering</code> label, we&#8217;ll provide the value <code class="literal">+Engineering</code> to the <code class="literal">labelFilter</code> parameter.
               </p>
               <p><span class="formalpara-title">The following returns the <code class="literal">Engineering</code> people reachable by the <code class="literal">KNOWS</code> relationship at 1 to 2 hops from Praveena.&nbsp;</span>
                  
               </p><pre class="programlisting highlight"><code data-lang="cypher">MATCH (p:Person {name: "Praveena"})
CALL apoc.path.subgraphNodes(p, {
	relationshipFilter: "KNOWS",
	labelFilter: "+Engineering",
    minLevel: 1,
    maxLevel: 2
})
YIELD node
RETURN node;</code></pre><p>
                  
               </p>
               <div class="table" id="d0e31716">
                  <table class="table" summary="Results" border="1">
                     <caption class="table-title">Table&nbsp;12.31.&nbsp;Results</caption>
                     <colgroup>
                        <col class="col_1"></col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th style="text-align: left; vertical-align: top; ">node</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Zhen"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Martin"})</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <p>We lose Lju and Stefan because those nodes don&#8217;t have the <code class="literal">Engineering</code> label.
               </p>
               <p>We can specify multiple relationship types.
                  The following query starts from the Alicia node, and then expands the <code class="literal">FOLLOWS</code> and <code class="literal">KNOWS</code> relationships:
               </p>
               <p id="expand-subgraph-nodes-examples-label-relationship-filters-alicia-all"><span class="formalpara-title">The following returns the people reachable by the <code class="literal">FOLLOWS</code> or <code class="literal">KNOWS</code> relationships at 1 to 3 hops from Alicia.&nbsp;</span>
                  
               </p><pre class="programlisting highlight"><code data-lang="cypher">MATCH (p:Person {name: "Alicia"})
CALL apoc.path.subgraphNodes(p, {
    relationshipFilter: "FOLLOWS&gt;|KNOWS",
    minLevel: 1,
    maxLevel: 3
})
YIELD node
RETURN node;</code></pre><p>
                  
               </p>
               <div class="table" id="d0e31761">
                  <table class="table" summary="Results" border="1">
                     <caption class="table-title">Table&nbsp;12.32.&nbsp;Results</caption>
                     <colgroup>
                        <col class="col_1"></col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th style="text-align: left; vertical-align: top; ">node</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Sales {name: "Jonny"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Field {name: "Joe"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Product {name: "Jake"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Sales {name: "Anthony"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Praveena"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:DevRel {name: "Mark"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Zhen"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Field {name: "Stefan"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Product {name: "John"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Martin"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:DevRel {name: "Lju"})</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <p>This list includes all but one of the people in our graph, which means that Alicia is very well connected.</p>
               <p>We can also specify traversal termination criteria using label filters.
                  If we wanted to terminate a traversal as soon as the traversal encounters a node containing the <code class="literal">Engineering</code> label, we can use the <code class="literal">/Engineering</code> node filter.
               </p>
               <p><span class="formalpara-title">The following returns the people reachable by the <code class="literal">FOLLOWS</code> or <code class="literal">KNOWS</code> relationships at 1 to 3 hops from Alicia, terminating as soon as a node with the <code class="literal">Engineering</code> label is reached.&nbsp;</span>
                  
               </p><pre class="programlisting highlight"><code data-lang="cypher">MATCH (p:Person {name: "Alicia"})
CALL apoc.path.subgraphNodes(p, {
    relationshipFilter: "FOLLOWS&gt;|KNOWS",
    labelFilter: "/Engineering",
    minLevel: 1,
    maxLevel: 3
})
YIELD node
RETURN node;</code></pre><p>
                  
               </p>
               <div class="table" id="d0e31842">
                  <table class="table" summary="Results" border="1">
                     <caption class="table-title">Table&nbsp;12.33.&nbsp;Results</caption>
                     <colgroup>
                        <col class="col_1"></col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th style="text-align: left; vertical-align: top; ">node</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Zhen"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Praveena"})</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <p>We&#8217;re now down to only 2 people - Zhen and Praveena.
                  But this query doesn&#8217;t capture all of the paths from Alicia that end in a node with the <code class="literal">Engineering</code> label.
                  We can use the <code class="literal">&gt;Engineering</code> node filter to define a traversal that:
               </p>
               <div class="itemizedlist">
                  <ul class="itemizedlist" style="list-style-type: disc; ">
                     <li class="listitem">only returns nodes that have the <code class="literal">Engineering</code> label
                     </li>
                     <li class="listitem">continues expansion to end nodes after that, looking for more nodes that have the <code class="literal">Engineering</code> label
                     </li>
                  </ul>
               </div>
               <p><span class="formalpara-title">The following returns <code class="literal">Engineering</code> people reachable by the <code class="literal">FOLLOWS</code> or <code class="literal">KNOWS</code> relationships at 1 to 3 hops from Alicia.&nbsp;</span>
                  
               </p><pre class="programlisting highlight"><code data-lang="cypher">MATCH (p:Person {name: "Alicia"})
CALL apoc.path.subgraphNodes(p, {
    relationshipFilter: "FOLLOWS&gt;|KNOWS",
    labelFilter: "&gt;Engineering",
    minLevel: 1,
    maxLevel: 3
})
YIELD node
RETURN node;</code></pre><p>
                  
               </p>
               <div class="table" id="d0e31898">
                  <table class="table" summary="Results" border="1">
                     <caption class="table-title">Table&nbsp;12.34.&nbsp;Results</caption>
                     <colgroup>
                        <col class="col_1"></col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th style="text-align: left; vertical-align: top; ">node</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Zhen"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Praveena"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Martin"})</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <p>Our query now also returns Martin, who must have been reachable via either Zhen or Praveena.</p>
            </section>
            <section class="section" id="expand-subgraph-nodes-examples-end-nodes-terminator-nodes">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a class="anchor" href="#expand-subgraph-nodes-examples-end-nodes-terminator-nodes"></a>12.4.3.2.&nbsp;Terminator Nodes and End Nodes
                        </h4>
                     </div>
                  </div>
               </div>
               <p>As well as specifying terminator and end labels for traversals, we can also specify terminator and end nodes.
                  For this procedure, these parameters both behave the same way - the procedure will determine whether any of the nodes provided
                  as terminator or end nodes are reachable from the start node.
               </p>
               <p>Let&#8217;s build on the previous query that found people that Alicia <code class="literal">KNOWS</code> or <code class="literal">FOLLOWS</code>.
                  We want to know whether there&#8217;s a way to get from Alicia to Joe, which we can do by passing the Joe node to the <code class="literal">terminatorNodes</code> parameter.
               </p>
               <p><span class="formalpara-title">The following returns the terminator nodes reachable by the <code class="literal">FOLLOWS</code> or <code class="literal">KNOWS</code> relationships at 1 to 3 hops from Alicia.&nbsp;</span>
                  
               </p><pre class="programlisting highlight"><code data-lang="cypher">MATCH (p:Person {name: "Alicia"})
MATCH (joe:Person {name: "Joe"})
CALL apoc.path.subgraphNodes(p, {
    relationshipFilter: "FOLLOWS&gt;|KNOWS",
    minLevel: 1,
    maxLevel: 3,
    terminatorNodes: [joe]
})
YIELD node
RETURN node;</code></pre><p>
                  
               </p>
               <div class="table" id="d0e31952">
                  <table class="table" summary="Results" border="1">
                     <caption class="table-title">Table&nbsp;12.35.&nbsp;Results</caption>
                     <colgroup>
                        <col class="col_1"></col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th style="text-align: left; vertical-align: top; ">node</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Field {name: "Joe"})</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <p>We do indeed have a path from Alicia to Joe.</p>
               <p>And we know from <a class="link" href="#expand-subgraph-nodes-examples-label-relationship-filters-alicia-all" title="The following returns the people reachable by the FOLLOWS or KNOWS relationships at 1 to 3 hops from Alicia">an earlier example</a> that Alicia can actually reach all other nodes in the graph using the <code class="literal">KNOWS</code> or <code class="literal">FOLLOWS</code> relationships.
                  But what if we want to determine whether Mark, Joe, Zhen, and Praveena are reachable using only the <code class="literal">KNOWS</code> relationship?
               </p>
               <p><span class="formalpara-title">The following returns the end nodes reachable by the <code class="literal">KNOWS</code> relationships at 1 to 3 hops from Alicia.&nbsp;</span>
                  
               </p><pre class="programlisting highlight"><code data-lang="cypher">MATCH (p:Person {name: "Alicia"})
MATCH (end:Person)
WHERE end.name IN ["Mark", "Joe", "Zhen", "Praveena"]
WITH p, collect(end) AS endNodes
CALL apoc.path.subgraphNodes(p, {
    relationshipFilter: "KNOWS",
    minLevel: 1,
    maxLevel: 3,
    endNodes: endNodes
})
YIELD node
RETURN node;</code></pre><p>
                  
               </p>
               <div class="table" id="d0e31993">
                  <table class="table" summary="Results" border="1">
                     <caption class="table-title">Table&nbsp;12.36.&nbsp;Results</caption>
                     <colgroup>
                        <col class="col_1"></col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th style="text-align: left; vertical-align: top; ">node</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:DevRel {name: "Mark"})</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <p>Only Mark is reachable!</p>
            </section>
            <section class="section" id="expand-subgraph-nodes-examples-whitelist-blacklist">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a class="anchor" href="#expand-subgraph-nodes-examples-whitelist-blacklist"></a>12.4.3.3.&nbsp;Whitelist Nodes and Blacklist Nodes
                        </h4>
                     </div>
                  </div>
               </div>
               <p>Whitelist and blacklist nodes can also be specified.</p>
               <p>Let&#8217;s build on the query that found people that Alicia <code class="literal">KNOWS</code> or <code class="literal">FOLLOWS</code>.
                  We want to find the nodes reachable via paths that only include Jonny, Mark, or Zhen.
                  We can do this by passing those odes to the parameter <code class="literal">whitelistNodes</code>.
               </p>
               <p><span class="formalpara-title">The following returns nodes reachable by the <code class="literal">FOLLOWS</code> or <code class="literal">KNOWS</code> relationship types at 1 to 3 hops from Alicia, where the paths to those nodes must only include Mark, Jonny, or Zhen.&nbsp;</span>
                  
               </p><pre class="programlisting highlight"><code data-lang="cypher">MATCH (p:Person {name: "Alicia"})
MATCH (whitelist:Person)
WHERE whitelist.name IN ["Jonny", "Mark", "Zhen"]
WITH p, collect(whitelist) AS whitelistNodes
CALL apoc.path.subgraphNodes(p, {
    relationshipFilter: "FOLLOWS&gt;|KNOWS",
    minLevel: 1,
    maxLevel: 3,
    whitelistNodes: whitelistNodes
})
YIELD node
RETURN node;</code></pre><p>
                  
               </p>
               <div class="table" id="d0e32039">
                  <table class="table" summary="Results" border="1">
                     <caption class="table-title">Table&nbsp;12.37.&nbsp;Results</caption>
                     <colgroup>
                        <col class="col_1"></col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th style="text-align: left; vertical-align: top; ">node</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Sales {name: "Jonny"})</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <p>Only Jonny can be reached.
                  We can therefore infer that Mark and Zhen are only reachable via another node that wasn&#8217;t include in the whitelist.
               </p>
               <p>A blacklist is used to exclude nodes from the paths that lead to reachable nodes.
                  If we want to return nodes that are reachable without going through Joe, we can do this by passing the Joe node to the <code class="literal">blacklistNodes</code> parameter.
               </p>
               <p><span class="formalpara-title">The following returns nodes reachable by the <code class="literal">FOLLOWS</code> or <code class="literal">KNOWS</code> relationship types at 1 to 3 hops from Alicia, where the paths to those nodes do not go through Joe.&nbsp;</span>
                  
               </p><pre class="programlisting highlight"><code data-lang="cypher">MATCH (p:Person {name: "Alicia"})
MATCH (joe:Person {name: "Joe"})
CALL apoc.path.subgraphNodes(p, {
    relationshipFilter: "FOLLOWS&gt;|KNOWS",
    minLevel: 1,
    maxLevel: 3,
    blacklistNodes: [joe]
})
YIELD node
RETURN node;</code></pre><p>
                  
               </p>
               <div class="table" id="d0e32074">
                  <table class="table" summary="Results" border="1">
                     <caption class="table-title">Table&nbsp;12.38.&nbsp;Results</caption>
                     <colgroup>
                        <col class="col_1"></col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th style="text-align: left; vertical-align: top; ">node</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Sales {name: "Jonny"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Product {name: "Jake"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Sales {name: "Anthony"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:DevRel {name: "Mark"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Field {name: "Stefan"})</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <p>Only 5 nodes are reachable without going through the Joe node.
                  If we remember back to <a class="link" href="#expand-subgraph-nodes-examples-label-relationship-filters-alicia-all" title="The following returns the people reachable by the FOLLOWS or KNOWS relationships at 1 to 3 hops from Alicia">an earlier example</a>, 11 nodes were reachable when we didn&#8217;t specify a blacklist.
                  This indicates that Joe is an important connector in this graph.
               </p>
            </section>
            <section class="section" id="expand-subgraph-nodes-examples-sequence-rel-types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a class="anchor" href="#expand-subgraph-nodes-examples-sequence-rel-types"></a>12.4.3.4.&nbsp;Sequences of relationship types
                        </h4>
                     </div>
                  </div>
               </div>
               <p>Sequences of relationship types can be specified by comma separating the values passed to <code class="literal">relationshipFilter</code>.
               </p>
               <p>For example, if we want to start from the Joe node and traverse a sequence of the <code class="literal">FOLLOWS</code> relationship in the outgoing direction and the <code class="literal">KNOWS</code> relationship in either direction, we can specify the relationship filter <code class="literal">FOLLOWS&gt;,KNOWS</code>.
               </p>
               <p><span class="formalpara-title">The following returns the reachable nodes by following the <code class="literal">FOLLOWS</code> and <code class="literal">KNOWS</code> relationship types alternately from Joe.&nbsp;</span>
                  
               </p><pre class="programlisting highlight"><code data-lang="cypher">MATCH (p:Person {name: "Joe"})
CALL apoc.path.subgraphNodes(p, {
	relationshipFilter: "FOLLOWS&gt;,KNOWS",
	beginSequenceAtStart: true,
	minLevel: 1,
	maxLevel: 4
})
YIELD node
RETURN node;</code></pre><p>
                  
               </p>
               <div class="table" id="d0e32142">
                  <table class="table" summary="Results" border="1">
                     <caption class="table-title">Table&nbsp;12.39.&nbsp;Results</caption>
                     <colgroup>
                        <col class="col_1"></col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th style="text-align: left; vertical-align: top; ">node</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Praveena"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:DevRel {name: "Mark"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Zhen"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Product {name: "Jake"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Engineering {name: "Martin"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:DevRel {name: "Lju"})</p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>(:Person:Field {name: "Stefan"})</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
            </section>
         </section>
      </section>
      <footer><script type="text/javascript">
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
          //Allow Linker
          ga('create', 'UA-1192232-34','auto', {'allowLinker': true});
          ga('send', 'pageview');
          // Load the plugin.
          ga('require', 'linker');
          // Define which domains to autoLink.
          ga('linker:autoLink', ['neo4j.org','neo4j.com','neotechnology.com','graphdatabases.com','graphconnect.com']);
        </script><script type="text/javascript">
          (function() {
          var didInit = false;
          function initMunchkin() {
            if(didInit === false) {
              didInit = true;
              Munchkin.init('710-RRC-335');
            }
          }
          var s = document.createElement('script');
          s.type = 'text/javascript';
          s.async = true;
          s.src = '//munchkin.marketo.net/munchkin.js';
          s.onreadystatechange = function() {
            if (this.readyState == 'complete' || this.readyState == 'loaded') {
              initMunchkin();
            }
          };
          s.onload = initMunchkin;
          document.getElementsByTagName('head')[0].appendChild(s);
          })();
        </script></footer>
   </body>
</html>